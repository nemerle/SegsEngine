#include "cpp_generator.h"

#include "cmake_support.h"
#include "type_system.h"
#include "type_mapper.h"

#include "EASTL/algorithm.h"
#include "EASTL/sort.h"

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>

namespace {
const char *plugin_header = R"(
/* AUTOGENERATED FILE - all changes will be overwritten */
#include "core/plugin_interfaces/PluginDeclarations.h"

class %plugin_name% : public QObject, public ScriptingGlueInterface {
    Q_PLUGIN_METADATA(IID "org.segs_engine.ScriptingGlue"  FILE "%plugin_name%_plugin.json")
    Q_INTERFACES(ScriptingGlueInterface)
    Q_OBJECT
public:
    bool register_methods() override;
};
)";
const char *plugin_cpp = R"(
/* AUTOGENERATED FILE - all changes will be overwritten */
#include "%plugin_name%.h"

%registry_externs%
bool %plugin_name%::register_methods() {
    bool res=true;
    %registry_calls%
    return res;
}
)";

const char *helper_classes=
R"(

#include "core/math/camera_matrix.h"
#include "modules/mono/glue/glue_header.h"
#include "modules/mono/mono_gd/gd_mono.h"
#include "modules/mono/mono_gd/gd_mono_marshal.h"
#include "servers/rendering_server.h"

using namespace GDMonoMarshal;
namespace {
struct AutoRef {
    Object *self;

    AutoRef(Object *s) : self(s) {}
    template<class T>
    operator Ref<T>() {
        static_assert (eastl::is_base_of<Object,T>::value);
        return Ref<T>((T*)self);
    }
    template<class T>
    operator T*() {
        static_assert (eastl::is_base_of<Object,T>::value);
        return static_cast<T *>(self);
    }
    operator RefPtr() {
        return Ref<RefCounted>((RefCounted*)self).get_ref_ptr();
    }
};

struct AutoUnwrap {
    Object *self;
    constexpr explicit AutoUnwrap(Object *s) : self(s) {}
    constexpr explicit AutoUnwrap(const Object *s) : self((Object *)s) {}
    explicit AutoUnwrap(const RefPtr &s) : self((Object *)reinterpret_cast<Ref<RefCounted> *>(s.get())->get()) {}

    template<class T>
    AutoUnwrap(const Ref<T> &s) : self(s.get()) {}

    constexpr operator Object*() {
        return self;
    }
};

struct ArrConverter {
   Array &a;
   constexpr ArrConverter(Array &v):a(v) {}
   constexpr ArrConverter(Array *v):a(*v) {}
   operator Array() const { return a; }
   template<class T>
   operator Vector<T>() const {
       Vector<T> res;
       res.reserve(a.size());
       for (const Variant& v : a.vals()) {
           res.emplace_back(v.as<T>());
       }
       return res;
   }
   template<class T>
   operator PoolVector<T>() const {
       PoolVector<T> res;
       for (const Variant& v : a.vals()) {
           res.push_back(v.as<T>());
       }
       return res;
   }
};

struct VectorAutoConverter {
    MonoArray *m_arr;
    VectorAutoConverter(MonoArray *arr) : m_arr(arr) {}
    template<class T>
    operator PoolVector<T> () {
        return ::mono_array_to_pool_vec<T>(m_arr);
    }
    template<class T>
    operator Vector<T> () {
        return ::mono_array_to_vector<T>(m_arr);
    }
    template<class T>
    operator Span<const T> () {
        return ::mono_array_as_span<T>(m_arr);
    }
};

Array *ToArray(Array && v) {
   return memnew(Array(eastl::move(v)));
}
template<class T>
Array *ToArray(const Vector<T> & v) {
   Array * res = memnew(Array());
   for(const T &val : v) {
       res->emplace_back(Variant::from(val));
   }
   return res;
}
template<>
Array* ToArray(const Vector<SurfaceArrays> &v) {
   Array* res = memnew(Array());
   for (const auto& val : v) {
       res->emplace_back(Array(val));
   }
   return res;
}

template<class T>
Array *ToArray(PoolVector<T> && v) {
   Array * res = memnew(Array());
   for(size_t idx=0,fin=v.size();idx<fin; ++idx) {
       res->emplace_back(Variant::from(v[idx]));
   }
   return res;
}
Array* ToArray(Frustum&& v) {
   Array* res = memnew(Array());
   for (const auto& val : v) {
       res->emplace_back(Variant::from(val));
   }
   return res;
}

Array* ToArray(SurfaceArrays&& v) {
   return memnew(Array(v));
}
} // end of anonymous namespace
)";

StringView replaceFunctionName(const TS_Function *finfo, bool in_godot_ns) {
    StringView from(finfo->c_name());
    StringView res = from;
    const TS_TypeLike *owner(finfo->enclosing_type);
    if(owner->c_name()=="Node") {
        if(res== "get_children")
            return "_get_children";
    }
    else if(owner->c_name()=="PacketPeer") {
        if(res== "get_var")
            return "_bnd_get_var";
    }
    else if(owner->c_name()=="TextEdit") {
        if(res== "search")
            return "_search_bind";
    }
    else if(owner->c_name()=="StreamPeer") {
        if(res== "get_data")
            return "_get_data";
    }
    else if(owner->c_name()=="ScriptEditor") {
        if(res== "goto_line")
            return "_goto_script_line2";
    }
    else if(owner->c_name()=="WebSocketServer") {
        //sigh, udp and tcp servers `_listen` but WebSocketServer `listen`s
        if(res== "listen")
            return "listen";
    }
    else if(owner->c_name()=="Tree") {
        if(res== "create_item")
            return "_create_item";

    }
    else if(owner->c_name()=="StreamPeerTCP") {
        if(res== "connect_to_host")
            return "_connect";

    }
    static const HashMap<StringView, StringView> s_entries = {
        { "_get_slide_collision", "get_slide_collision" },
        { "_set_import_path", "set_import_path" },
        { "add_do_method", "_add_do_method" },
        { "add_property_info", "_add_property_info_bind" },
        { "add_surface_from_arrays", "_add_surface_from_arrays" },
        { "add_undo_method", "_add_undo_method" },
        { "body_test_motion", "_body_test_motion" },
        { "call_recursive", "_call_recursive_bind" },
        { "class_get_category", "get_category" },
        { "class_get_integer_constant", "get_integer_constant" },
        { "class_get_integer_constant_list", "get_integer_constant_list" },
        { "class_get_method_list", "get_method_list" },
        { "class_get_property", "get_property" },
        { "class_get_property_list", "get_property_list" },
        { "class_get_signal", "get_signal" },
        { "class_get_signal_list", "get_signal_list" },
        { "class_has_integer_constant", "has_integer_constant" },
        { "class_has_method", "has_method" },
        { "class_has_signal", "has_signal" },
        { "class_set_property", "set_property" },
        { "copy_from", "copy_internals_from" },
        { "create_from_data", "_create_from_data" },
        { "get_action_list", "_get_action_list" },
        { "get_connection_list", "_get_connection_list" },
        { "get_groups", "_get_groups" },
        { "get_item_area_rect","_get_item_rect"},
        { "get_item_shapes", "_get_item_shapes" },
        { "get_local_addresses", "_get_local_addresses" },
        { "get_local_interfaces", "_get_local_interfaces" },
        { "get_named_attribute_value", "get_attribute_value" },
        { "get_named_attribute_value_safe", "get_attribute_value_safe" },
        { "get_next_selected","_get_next_selected"},
        { "get_node_and_resource", "_get_node_and_resource" },
        { "get_node_connections", "_get_node_connections" },
        { "get_range_config","_get_range_config"},
        { "get_response_headers", "_get_response_headers" },
        { "get_shape_owners", "_get_shape_owners" },
        { "get_slide_collision", "_get_slide_collision" },
        { "get_tiles_ids","_get_tiles_ids"},
        { "get_transformable_selected_nodes", "_get_transformable_selected_nodes" },
        { "make_mesh_previews", "_make_mesh_previews" },
        { "move_and_collide", "_move" },
        { "move_local_x", "move_x" },
        { "move_local_y", "move_y" },
        { "new", "_new" },
        { "open_encrypted_with_pass", "open_encrypted_pass" },
        { "queue_free", "queue_delete" },
        { "rpc", "_rpc_bind" },
        { "rpc_id", "_rpc_id_bind" },
        { "rpc_unreliable", "_rpc_unreliable_bind" },
        { "rpc_unreliable_id", "_rpc_unreliable_id_bind" },
        { "set_item_shapes", "_set_item_shapes" },
        { "set_navigation", "set_navigation_node" },
        { "set_target", "_set_target" },
        { "set_variable_info","_set_variable_info"},
        { "surface_get_blend_shape_arrays", "_surface_get_blend_shape_arrays" },
        { "take_over_path", "set_path" },
        {"_get_gizmo_extents","get_gizmo_extents"},
        {"_set_gizmo_extents","set_gizmo_extents"},
        {"add_user_signal","_add_user_signal"},
        {"call","_call_bind"},
        {"call_deferred","_call_deferred_bind"},
        {"call_group_flags","_call_group_flags"},
        {"cast_motion","_cast_motion"},
        {"collide_shape","_collide_shape"},
//        {"emit_signal","_emit_signal"},
        {"force_draw","draw"},
        {"get_bound_child_nodes_to_bone","_get_bound_child_nodes_to_bone"},
        {"get_breakpoints","get_breakpoints_array"},
        {"get_color_list","_get_color_list"},
        {"get_constant_list","_get_constant_list"},
        {"get_current_script","_get_current_script"},
        {"get_default_font","get_default_theme_font"},
        {"get_expand_margin","get_expand_margin_size"},
        {"get_font_list","_get_font_list"},
        {"get_icon_list","_get_icon_list"},
        {"get_incoming_connections","_get_incoming_connections"},
        {"get_indexed","_get_indexed_bind"},
        {"get_message_list","_get_message_list"},
        {"get_meta_list","_get_meta_list_bind"},
        {"get_method_list","_get_method_list_bind"},
        {"get_open_scripts","_get_open_scripts"},
        {"get_packet","_get_packet"},
        {"get_packet_error","_get_packet_error"},
        {"get_packet_ip","_get_packet_ip"},
        {"get_partial_data","_get_partial_data"},
        {"get_property_list","_get_property_list_bind"},
        {"get_property_default_value","_get_property_default_value"},
        {"get_resource_list","_get_resource_list"},
        {"get_rest_info","_get_rest_info"},
        //{"get_scancode_with_modifiers","get_keycode_with_modifiers"},
        {"get_script_method_list","_get_script_method_list"},
        {"get_script_signal_list","_get_script_signal_list"},
        {"get_script_property_list","_get_script_property_list"},
        {"get_signal_connection_list","_get_signal_connection_list"},
        {"get_script_constant_map","_get_script_constant_map"},
        {"get_signal_list","_get_signal_list"},
        {"get_stylebox_list","_get_stylebox_list"},
        {"get_type_list","_get_type_list"},
        {"has_user_signal","_has_user_signal"},
        {"instances_cull_convex","_instances_cull_convex_bind"},
        {"intersect_point","_intersect_point"},
        {"intersect_point_on_canvas","_intersect_point_on_canvas"},
        {"intersect_ray","_intersect_ray"},
        {"intersect_shape","_intersect_shape"},
        {"is_hide_on_state_item_selection","is_hide_on_multistate_item_selection"},
        {"listen","_listen"},
        {"load_resource_pack","_load_resource_pack"},
        {"mesh_add_surface_from_arrays","_mesh_add_surface_from_arrays"},
        {"newline","add_newline"},
        {"physical_bones_start_simulation","physical_bones_start_simulation_on"},
        {"put_data","_put_data"},
        {"put_packet","_put_packet"},
        {"put_partial_data","_put_partial_data"},
        {"set_dest_address","_set_dest_address"},
        {"set_expand_margin","set_expand_margin_size"},
        {"set_expand_margin_all","set_expand_margin_size_all"},
        {"set_expand_margin_individual","set_expand_margin_size_individual"},
        {"set_hide_on_state_item_selection","set_hide_on_multistate_item_selection"},
        {"set_indexed","_set_indexed_bind"},
        {"shader_get_param_list","_shader_get_param_list_bind"},
        {"share","_share"},
        {"test_motion","_test_motion"},
        {"texture_debug_usage","_texture_debug_usage_bind"},
        {"tile_set_shapes","_tile_set_shapes"},

        {"call_group","_call_group"},
        {"get_nodes_in_group","_get_nodes_in_group"},
        {"tile_get_shapes","_tile_get_shapes"},
        {"_set_editor_description","set_editor_description"},
        { "_get_editor_description","get_editor_description" },
    };
    if(!in_godot_ns) {
        return res;
    }
    auto iter = s_entries.find(from);
    if (iter != s_entries.end())
        return iter->second;

    return res;
}

}

void CppGeneratorVisitor::visitNamespace(TS_Namespace *ns) {
    m_namespace_stack.push_back(ns);
    auto &icalls(m_namespace_files.emplace_back());
    icalls.tgt_file_path = String::joined(m_path_components,"/")+"/"+ns->cs_name()+"_icalls.cpp";

    visitType_CollectHeaders(m_ctx,ns);
    auto hdrs=m_known_includes.keys();
    eastl::sort(hdrs.begin(),hdrs.end());

    icalls.append_line("/* AUTOGENERATED FILE - all changes will be overwritten */");

    icalls.out.append("#include \"");
    icalls.out.append(plugin_name);
    icalls.out.append(".h\"\n\n");

    for(const auto &include : hdrs) {
        icalls.out.append("#include \"");
        icalls.out.append(include);
        icalls.out.append("\"\n");
    }
    icalls.append_line("//End of type headers");

    icalls.out.append(helper_classes);
    icalls.append_line("//End of helper types");
    icalls.append_line("//Prevent qt macro from clashing with argument names");
    icalls.append_line("#undef signals");
    String registration_func = m_current_module->m_name+"_"+ns->cs_name()+"_icalls()";
    icalls.out.append_indented("bool ");
    icalls.out.append(registration_func);
    icalls.out.append("\n");

    icalls.start_block();
        visitType(m_ctx,ns);

    icalls.append_line("return true;");
    icalls.end_block();

    m_registration_names.emplace_back(eastl::move(registration_func));
    m_namespace_stack.pop_back();
}

void CppGeneratorVisitor::visit(const ReflectionData *refl) {
    do_visit_recursive(refl,true,&m_ctx.m_rd!=refl);
}

void CppGeneratorVisitor::visitType_CollectHeaders(ProjectContext &ctx, const TS_TypeLike *iface) {
    if(iface->kind()==TS_TypeLike::CLASS && !m_known_includes.contains(((const TS_Type *)iface)->source_type->header_path)) {
        StringView hdr(((const TS_Type *)iface)->source_type->header_path);
        if(!hdr.empty()) // some opaque types can have empty include paths
            m_known_includes.emplace(hdr);

    }

    for(const auto &tp : iface->m_children) {
        visitType_CollectHeaders(ctx,tp);
    }
}

void CppGeneratorVisitor::visitType(ProjectContext &ctx, const TS_TypeLike *iface) {
    auto &m_cpp_icalls(m_namespace_files.back());

    if (iface->m_imported) // whole type is imported, skip it.
        return;

    for(const auto &tp : iface->m_children) {
        visitType(ctx,tp);
    }
    for(const auto &tp : iface->m_functions) {
        visitFunction(tp);
    }

    //In classes, process special functions.
    if(iface->kind() != TS_TypeLike::CLASS)
        return;

    if(iface->m_skip_special_functions) // forced to skip special functions.
        return;
    String basens = m_namespace_stack.back()->cs_name() + "." + m_current_module->m_name + "NativeCalls::";

    const TS_Type *classtype((const TS_Type *)iface);
    if(classtype->source_type->is_singleton) {
        m_cpp_icalls.out.append_indented("mono_add_internal_call(\"");
        m_cpp_icalls.out.append(basens+c_special_func_name_to_icall(iface,SpecialFuncType::Singleton));
        m_cpp_icalls.out.append("\", (void *)+[]() -> Object * ");
        m_cpp_icalls.start_block();
        m_cpp_icalls.out.indent();
        m_cpp_icalls.out.append_indented("return Engine::get_singleton()->get_named_singleton(\"");
        StringView type_name(classtype->c_name());
        if (type_name.starts_with('_')) // types starting with '_' are assumed to wrap the non-prefixed class for script acces.
            type_name = type_name.substr(1);
        m_cpp_icalls.out.append(String(type_name));
        m_cpp_icalls.out.append("\");\n");
        m_cpp_icalls.end_block();
        m_cpp_icalls.out.dedent();
        m_cpp_icalls.out.append(");\n");

    }
    if(iface->base_type!=nullptr && classtype->source_type->is_instantiable) {
        m_cpp_icalls.out.append_indented("mono_add_internal_call(\"");
        m_cpp_icalls.out.append(basens + c_special_func_name_to_icall(iface,SpecialFuncType::Constructor));
        m_cpp_icalls.out.append("\", (void *)+[](MonoObject* obj) -> Object * ");
        m_cpp_icalls.start_block();
        m_cpp_icalls.out.indent();
        m_cpp_icalls.out.append_indented("GODOTSHARP_INSTANCE_OBJECT(instance,\"");
        m_cpp_icalls.out.append(classtype->c_name());
        m_cpp_icalls.out.append("\");\n");
        //FIXME: handle constructors better ( especially classes that should be constructed in a special way : WebSocketPeer::create, and without going through ClassDB.
        //                m_cpp_icalls.out.append_indented("auto instance = new ");
        //                m_cpp_icalls.out.append(classtype->c_name());
        //                m_cpp_icalls.out.append("();\n");
        m_cpp_icalls.append_line("GDMonoInternals::tie_managed_to_unmanaged(obj, instance);");
        m_cpp_icalls.append_line("return instance;");
        m_cpp_icalls.end_block();
        m_cpp_icalls.out.dedent();
        m_cpp_icalls.out.append(");\n");
    }
}

void CppGeneratorVisitor::mapFunctionArguments(const TS_Function *finfo) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto &m_cpp_icalls(m_namespace_files.back());

    m_cpp_icalls.out.append("(Object * ptr");
    int argc = finfo->arg_types.size();

    for(int i=0; i<argc; ++i) {
        auto mapping = mapper.map_type(TS_TypeMapper::CPP_TO_WRAP_TYPE,finfo->arg_types[i]);
        m_cpp_icalls.out.append(", ");
        if(!mapping.empty())
            m_cpp_icalls.out.append(mapping);
        else {
            m_cpp_icalls.out.append("MissingWrap<");
            m_cpp_icalls.out.append(finfo->arg_types[i].type->c_name());
            m_cpp_icalls.out.append(">");
        }
        m_cpp_icalls.out.append(" ");
        m_cpp_icalls.out.append(finfo->arg_values[i]);
    }
    auto out_mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_ARGOUT,finfo->return_type);
    if(!out_mapping.empty()) {
        auto mapping = mapper.map_type(TS_TypeMapper::CPP_TO_WRAP_TYPE,finfo->return_type);
        m_cpp_icalls.out.append(", ");
        m_cpp_icalls.out.append(mapping);
        m_cpp_icalls.out.append(" ");
        m_cpp_icalls.out.append(out_mapping.replaced("%input%","_out_val"));
    }
    m_cpp_icalls.out.append(") ");
}
static constexpr const char *ptr_check_on_out_ptr = R"(
if(ptr==nullptr) {
    if(_out_val!=nullptr) {
        *_out_val = {};
    }
    ERR_FAIL_MSG("Parameter 'ptr' is null.");
}
)";
void CppGeneratorVisitor::verifyMethodSelfPtr(const TS_Function *finfo, bool non_void_return) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto &m_cpp_icalls(m_namespace_files.back());

    if(non_void_return) {
        auto out_mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_ARGOUT,finfo->return_type);
        // non void return but through out-arg:
        if(!out_mapping.empty()) {
            m_cpp_icalls.append_multiline(ptr_check_on_out_ptr);
        }
        else
            m_cpp_icalls.append_line("ERR_FAIL_NULL_V(ptr, {});\n");
    }
    else {
        m_cpp_icalls.append_line("ERR_FAIL_NULL(ptr);\n");
    }
}

String CppGeneratorVisitor::prepareInstanceVariable(const TS_Function *finfo) {
    auto &m_cpp_icalls(m_namespace_files.back());
    if(finfo->enclosing_type) {
        m_cpp_icalls.out.append_indented("auto self = static_cast<");
        m_cpp_icalls.out.append(finfo->enclosing_type->c_name());
        m_cpp_icalls.out.append(" *>(ptr);\n");
        return String("self");
    }
    return "";
}

void CppGeneratorVisitor::prepareArgumentLocals(const TS_Function *finfo, eastl::vector_map<String, String> &mapped_args) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto &m_cpp_icalls(m_namespace_files.back());
    int argc = finfo->arg_types.size();
    bool func_is_vararg=finfo->source_type->is_vararg;
    int additional_argc=0; // used by vararg functions
    Vector<String> process_varargs;
    for (int i = 0; i < argc; ++i) {
        auto mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_IN, finfo->arg_types[i]);
        bool multiline_mapping = mapping.contains('\n');
        auto input_wrap = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_IN_ARG, finfo->arg_types[i]);

        if(func_is_vararg && !multiline_mapping) {
            additional_argc++;
            mapped_args[finfo->arg_values[i]] = ""; // this argument was packed into varargs parameter.
            if(mapping.empty()) {
                String vararged;
                String locarg(finfo->arg_values[i]);
                vararged += "Variant v_"+locarg + "(Variant::from(" +locarg+"));\n";
                vararged += String().sprintf("temp_var_args[%d] = &v_%s;\n",i,locarg.c_str());
                process_varargs.emplace_back(eastl::move(vararged));
            }
        }
        // WRAP_TO_CPP_IN_ARG
        if (mapping.empty()) {
            continue;
        }
        // FIXME: brittle way of detecting non-vararg parts of
        String locarg("temp_" + finfo->arg_values[i]);
        // Multiline mappings are not recording their temp names
        if(!multiline_mapping && !func_is_vararg) {
            mapped_args[finfo->arg_values[i]] = locarg;
        }
        auto input_arg = finfo->arg_values[i];
        // multiline mappings will not use `input_wrap`
        if (!multiline_mapping && !input_wrap.empty()) {
            input_arg = input_wrap.replaced("%input%", input_arg);
        }
        String realized_mapping(mapping.replaced("%val%", locarg)
                                .replaced("%input%", input_arg)
                                .replaced("%type%", finfo->arg_types[i].to_c_type(m_namespace_stack.back())));
        if(!multiline_mapping) {
            if(func_is_vararg) {
                String vararged;
                vararged += "Variant v_"+locarg + "(Variant::from(" +locarg+"));\n";
                vararged += String().sprintf("temp_var_args[%d] = &v_%s;\n",i,locarg.c_str());
                process_varargs.emplace_back(eastl::move(vararged));

            }
            m_cpp_icalls.out.append_indented(realized_mapping);
            m_cpp_icalls.out.append(";\n");
        }
        else {
            // this might be vararg thing
            realized_mapping.replace("%additional_argc%",String().sprintf("%d",additional_argc));
            if(process_varargs.empty())
                realized_mapping.replace("%process_varargs%","/*No additional args*/");
            else
                realized_mapping.replace("%process_varargs%",String::joined(process_varargs,""));

            m_cpp_icalls.out.append_indented_multiline(realized_mapping);
        }
    }
}

static const TS_TypeLike *top_level_ns(const TS_TypeLike *base) {
    while(base) {
        if(base->nested_in) {
            base = base->nested_in;
        }
        else
            if(base->kind()==TS_TypeLike::NAMESPACE) {
                return base;
            }
    }
    return nullptr;
}
static void buildCallArgumentList(const TS_Function *finfo, eastl::vector_map<String, String> &mapped_args,StringBuilder &out) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    int argc = finfo->arg_types.size();
    FixedVector<String,32,false> arg_parts;

    out.append("(");
    for(int i=0; i<argc; ++i) {
        auto mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_IN_ARG,finfo->arg_types[i]);
        auto input_arg(finfo->arg_values[i]);
        auto input_type(finfo->arg_types[i]);

        auto iter = mapped_args.find(input_arg);
        if(iter!=mapped_args.end()) {
            if(iter->second.empty()) // skip parameter that was packed into the varargs array.
                continue;
            input_arg = iter->second;
        }
        else if(!mapping.empty()) {
            input_arg = eastl::move(mapping.replaced("%input%",input_arg));
        }
        else if(input_type.type->kind()==TS_TypeLike::ENUM) {
            String enum_type=input_type.to_c_type(top_level_ns(input_type.type));
            input_arg = eastl::move(enum_type+"("+input_arg+")");
        }
        arg_parts.emplace_back(eastl::move(input_arg));

    }
    out.append(String::joined(arg_parts," ,"));
    out.append(")");
}

String CppGeneratorVisitor::mapReturnType(const TS_Function *finfo) {
    TS_TypeMapper &mapper(TS_TypeMapper::get());
    auto mapping = mapper.map_type(TS_TypeMapper::CPP_TO_WRAP_TYPE_OUT,finfo->return_type);
    if(mapping.empty())
        mapping = mapper.map_type(TS_TypeMapper::CPP_TO_WRAP_TYPE,finfo->return_type);

    auto outret_mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_ARGOUT,finfo->return_type);
    //FIXME: find a better way of detecting/handling output values returned in arguments.
    if(!outret_mapping.empty()) {
        return "void ";
    }
    StringView cname(finfo->return_type.type->c_name());
    if(mapping.empty()) {
        return String(String::CtorSprintf(), "MissingReturnMap<%.*s>", (int)cname.length(), cname.data());
    }
    if(mapping.empty()) {
        return String(cname);
    }
    else {
        mapping.replace("%type%",finfo->return_type.type->c_name());

    }
    return mapping;
}

void applyReturnMapping(const TS_Function *finfo,StringBuilder &out,const String &value) {

    TS_TypeMapper &mapper(TS_TypeMapper::get());

    auto mapping = mapper.map_type(TS_TypeMapper::CPP_TO_WRAP_TYPE,finfo->return_type);
    auto out_mapping = mapper.map_type(TS_TypeMapper::WRAP_TO_CPP_OUT,finfo->return_type);

    if(!out_mapping.empty()) {
        // return but empty mapping -> return through out parameter
        String expr(out_mapping);
        expr.replace("%type%",mapping);
        expr.replace("%result%","_out_val");
        if(finfo->return_type.type->kind()==TS_TypeLike::ENUM) {
            expr.replace("%val%",mapping+String("("+value+")")); // wrap enums in underlying type
        }
        else
            expr.replace("%val%",value);
        out.append_indented(expr);
        out.append(";\n"); // out val assigned
        return;
    }
    if(mapping.empty()) {
        out.append_indented("return ");
        out.append(value);
        out.append("; /* no return/outval mapping defined*/\n");
    }
    else {
        String result = mapping;
        result.replace("%type%",finfo->return_type.type->c_name());
        out.append_indented("return ");
        out.append(result);
        out.append(";\n");

    }
}

void CppGeneratorVisitor::visitFunction(const TS_Function *finfo) {
    const bool non_void_return=finfo->return_type.type->c_name()!=StringView("void");
    auto &m_cpp_icalls(m_namespace_files.back());

    //TODO: handle virtual methods better than using call-by-name from c#?
    if (finfo->source_type->is_virtual)
        return;
    if (finfo->m_imported) // skip functions marked as imported
        return;
    //FIXME: sigh...
    if(finfo->c_name()=="free" && finfo->enclosing_type->c_name()=="Object") {

        return;
    }

    m_cpp_icalls.out.append_indented("mono_add_internal_call(\"");
    String basens = m_namespace_stack.back()->cs_name() + "." + m_current_module->m_name + "NativeCalls::";

    m_cpp_icalls.out.append(basens+c_func_name_to_icall(finfo));
    m_cpp_icalls.out.append("\", (void *)+[]");
    // Perform argument type mappings.
    mapFunctionArguments(finfo);
    String return_type(mapReturnType(finfo));
    if("void" != return_type) {
        m_cpp_icalls.out.append("-> ");
        m_cpp_icalls.out.append(return_type);
    }
    else
        m_cpp_icalls.out.append(" ");

    m_cpp_icalls.out.append("{\n");
    m_cpp_icalls.out.indent(2);

    verifyMethodSelfPtr(finfo,non_void_return);

    String instance=prepareInstanceVariable(finfo);

    // Perform mono to cpp type conversions.
    eastl::vector_map<String,String> arg_locals;
    prepareArgumentLocals(finfo,arg_locals);

    StringBuilder func_call;
    if(!instance.empty()) {
        func_call.append(instance);
        func_call.append("->");
    }
    func_call.append(replaceFunctionName(finfo,m_namespace_stack.back()->c_name()=="Godot"));

    buildCallArgumentList(finfo,arg_locals,func_call);

    if(non_void_return) {
        applyReturnMapping(finfo,m_cpp_icalls.out,func_call.as_string());
    }
    else {
        m_cpp_icalls.out.append_indented(func_call.as_string());
        m_cpp_icalls.out.append(";\n");
    }
    m_cpp_icalls.end_block();
    m_cpp_icalls.out.dedent();
    m_cpp_icalls.out.append_indented(");\n");
}

void CppGeneratorVisitor::fillPluginMetadata(QJsonObject &tgt)
{
    tgt["Name"] = plugin_name.c_str();
    tgt["GeneratorVersion"] = QString::number(g_generator_version);
    tgt["Version"] = m_ctx.m_rd.version.c_str();
    tgt["ApiVersion"] = m_ctx.m_rd.api_version.c_str();
    tgt["ApiHash"] = m_ctx.m_rd.api_hash.c_str();
#ifndef NDEBUG
    tgt["Mode"] = "Debug";
#else
    tgt["Mode"] = "Release";
#endif
    if(!m_ctx.m_rd.imports.empty()) {
        QJsonArray arr;
        for(const auto &id : m_ctx.m_rd.imports) {
            QJsonObject dep;
            dep["Name"] = id.module_name.c_str();
            dep["ApiVersion"] = id.api_version.c_str();
            arr.push_back(dep);
        }
        tgt["Dependecies"]=arr;
    }
}

CppGeneratorVisitor::CppGeneratorVisitor(ProjectContext &ctx) : ReflectionVisitorBase(ctx) {

}

void CppGeneratorVisitor::finalize()
{
    String extern_registrations;
    String registration_calls;
    m_path_components.emplace_back(m_ctx.m_rd.module_name);
    m_path_components.emplace_back("cpp");

    for(StringView name : m_registration_names) {
        extern_registrations += "extern bool "+name+";\n";
        registration_calls += "    res &= " + name+";\n";
    }
    //FIXME: this is a hack to add hand-generated c# internal calls in GodotCore.
    if(plugin_name =="GodotCore")
    {
        extern_registrations +="extern void godot_register_glue_header_icalls();\n";
        registration_calls += "    godot_register_glue_header_icalls();\n";
    }
    m_plugin_header.out.append(String(plugin_header).replaced("%plugin_name%",plugin_name));
    m_ctx.write_string_builder(String::joined(m_path_components,"/")+"/"+plugin_name+".h",m_plugin_header.out);

    m_plugin_wrapper.out.append(String(plugin_cpp)
                                .replaced("%plugin_name%",plugin_name)
                                .replaced("%registry_externs%",extern_registrations)
                                .replaced("%registry_calls%",registration_calls)
    );
    m_ctx.write_string_builder(String::joined(m_path_components,"/")+"/"+plugin_name+".cpp",m_plugin_wrapper.out);

    for(const auto &ns : m_namespace_files) {
        m_ctx.write_string_builder(ns.tgt_file_path,ns.out);
    }
    QJsonDocument doc;
    QJsonObject root;
    fillPluginMetadata(root);
    doc.setObject(root);
    QString json_data=doc.toJson(QJsonDocument::Indented);
    m_ctx.write_string(String::joined(m_path_components,"/")+"/"+plugin_name+"_plugin.json",qPrintable(json_data));
    m_path_components.pop_back();
    m_path_components.pop_back();
}

void CppGeneratorVisitor::visitModule(TS_Module *mod)
{
    if(mod->m_imported) // don't generate anything for imported modules.
        return;
    m_path_components.emplace_back(mod->m_name);
    m_path_components.emplace_back("cpp");
    plugin_name = mod->m_name;
    Super::visitModule(mod); // use parent class functionality for the non-imported case.
    m_path_components.pop_back();
    m_path_components.pop_back();
}
